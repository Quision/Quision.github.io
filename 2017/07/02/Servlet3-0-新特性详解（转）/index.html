<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>Servlet3.0 新特性详解（转） | Quison's Blog</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Servlet3.0 新特性详解（转）</h1><a id="logo" href="/.">Quison's Blog</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Servlet3.0 新特性详解（转）</h1><div class="post-meta">Jul 2, 2017<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-disqus-identifier="2017/07/02/Servlet3-0-新特性详解（转）/" href="/2017/07/02/Servlet3-0-新特性详解（转）/#disqus_thread" class="disqus-comment-count"></a><div class="post-content"><p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-servlet30/" target="_blank" rel="external">原文链接</a></p>
<h2 id="1、Servlet3-0-新特性概述"><a href="#1、Servlet3-0-新特性概述" class="headerlink" title="1、Servlet3.0 新特性概述"></a>1、Servlet3.0 新特性概述</h2><p>　　Servlet3.0 作为Java EE 6 规范体系中的一员，随着Java EE 6规范一起发布。该版本在前一半（Servlet 2.5）的基础上提供了若干新特性用于简化Web应用的开发和部署。其中有几项特性的引入让开发者感到非常兴奋，同时也获得了Java社区的一片赞誉之声：</p>
<ol>
<li>异步处理支持：有了该特性，Servlet线程不再需要一直阻塞，直到业务处理完毕才能输出响应，最后才结束该Servlet线程。在接收到请求之后，Servlet线程可以将耗时的操作委派给另一个线程来完成，自己在不生成响应的情况下返回至容器。针对业务处理较耗时的情况，这将大大减少服务器资源的占用，并且提高并发处理速度；</li>
<li>新增的注解支持：该版本新增了若干注解，用于简化Servlet、过滤器（Filter）和监听器（Listener）的声明，这使得web.xml部署描述文件从该版本开始不再是必选的了；</li>
<li>可插性支持：熟悉Struts2的开发者一定会对其通过插件的方式与包括Spring在内的各种常用框架整合记忆犹新。将相应的插件封装成JAR包并放在类路径下，Struts2运行时便能自动加载这些插件。现在Servlet3.0提供了类似的特性，开发者可以通过插件的方式很方便的扩充已有Web应用的功能，而不需要修改原有的应用。</li>
</ol>
<p>　　下面我们将逐一讲解这些新特性，通过下面的学习，读者将能够明晰连接Servlet3.0的变化，并能够顺利使用它进行日常的开发工作。</p>
<h2 id="2、异步处理支持"><a href="#2、异步处理支持" class="headerlink" title="2、异步处理支持"></a>2、异步处理支持</h2><p>　　　在Servlet 3.0之前，一个普通的Servlet的主要工作流程大致如下：首先，Servlet接收到请求之后，可能需要对请求携带的数据进行一些预处理；接着，调用业务接口的某些方法，以完成业务处理；最后根据处理的结果提交响应，Servlet线程结束。其中第二步的业务处理通常是最耗时的，这主要体现在数据库操作，以及其他的跨网络调用等，在此过程中，Servlet线程一直处于阻塞状态，直到业务方法执行完毕，在处理业务的过程中，Servlet资源一直被占用而得不到是否，对于并发较大的应用，这有可能造成性能瓶颈对此，在以前通常是采用私有解决方案来提前结束Servlet线程，并及时是否资源。<br>　　　Servlet3.0针对这个问题做了开创性的工作，现在通过使用Servlet 3.0的异步处理支持，之前的Servlet处理流程可以调整为如下的过程：首先，Servlet接收到请求之后，可能首先需要对请求携带的数据进行一些预处理；接着，Servlet线程将请求转交给一个异步线程来执行业务处理，线程本身返回至容器，此时Servlet还没生产响应数据，异步线程处理完业务以后，可以直接生产响应数据（异步线程拥有SerlvetRequest和SerlvetResponse对象的引用），或者将请求继续转发给其他Servlet。如此一来，Serlvet线程不再是一直处于阻塞状态以等待业务逻辑的处理，而是启动异步线程之后可以立即返回。<br>　　　异步处理特性可以应用于Servlet和过滤器两种组件，由于异步处理的工作模式和普通工作模式在实现上有着本质的区别，因此默认情况下，Servlet和过滤器并没有开启异步处理特性，如果希望使用该特性，则必须按照如下方式启用：</p>
<ol>
<li><p>对于传统的部署描述文件（web.xml）配置Servlet和过滤器的情况，Servlet 3.0为<code>&lt;serlvet&gt;</code>和<code>&lt;filter&gt;</code> 标签增加了<code>&lt;async-supported&gt;</code>子标签，该标签的默认取值为false，要启用异步处理支持，则将其设为true即可。以Servlet为例，其配置方式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt; </div><div class="line">    &lt;servlet-name&gt;DemoServlet&lt;/servlet-name&gt; </div><div class="line">    &lt;servlet-class&gt;footmark.servlet.Demo Servlet&lt;/servlet-class&gt; </div><div class="line">    &lt;async-supported&gt;true&lt;/async-supported&gt; </div><div class="line">&lt;/servlet&gt;</div></pre></td></tr></table></figure>
</li>
<li><p>对于使用Servlet 3.0提供的@WebServlet和@WebFilter进行Servlet或过滤器配置的情况，这两个注解都提供了asyncSupported属性，默认该属性的取值为false，要启用异步处理支持，只需将该属性设置为true即可。以@WebFilter为例，其配置方式如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@WebFilter(urlPatterns = &quot;/demo&quot;,asyncSupported = true) </div><div class="line">public class DemoFilter implements Filter&#123;...&#125;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>　　一个简单的模拟异步处理的Servlet实例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">@WebServlet(urlPatterns = &quot;/demo&quot;, asyncSupported = true)</div><div class="line">public class AsyncDemoServlet extends HttpServlet &#123;</div><div class="line">    @Override</div><div class="line">    public void doGet(HttpServletRequest req, HttpServletResponse resp)</div><div class="line">    throws IOException, ServletException &#123;</div><div class="line">        resp.setContentType(&quot;text/html;charset=UTF-8&quot;);</div><div class="line">        PrintWriter out = resp.getWriter();</div><div class="line">        out.println(&quot;进入Servlet的时间：&quot; + new Date() + &quot;.&quot;);</div><div class="line">        out.flush();</div><div class="line"> </div><div class="line">        //在子线程中执行业务调用，并由其负责输出响应，主线程退出</div><div class="line">        AsyncContext ctx = req.startAsync();</div><div class="line">        new Thread(new Executor(ctx)).start();</div><div class="line"> </div><div class="line">        out.println(&quot;结束Servlet的时间：&quot; + new Date() + &quot;.&quot;);</div><div class="line">        out.flush();</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">public class Executor implements Runnable &#123;</div><div class="line">    private AsyncContext ctx = null;</div><div class="line">    public Executor(AsyncContext ctx)&#123;</div><div class="line">        this.ctx = ctx;</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    public void run()&#123;</div><div class="line">        try &#123;</div><div class="line">            //等待十秒钟，以模拟业务方法的执行</div><div class="line">            Thread.sleep(10000);</div><div class="line">            PrintWriter out = ctx.getResponse().getWriter();</div><div class="line">            out.println(&quot;业务处理完毕的时间：&quot; + new Date() + &quot;.&quot;);</div><div class="line">            out.flush();</div><div class="line">            ctx.complete();</div><div class="line">        &#125; catch (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>　　除此之外，Servlet 3.0 还为异步处理提供了一个监听器，使用AsyncListener接口表示。它可以监控如下四种事件：</p>
<ol>
<li>异步线程开始时，调用AsyncListener的onStartAsync(AsyncEvent event）方法；</li>
<li>异步线程出错时，调用AsyncListener的onError(AsyncEvent event）方法；</li>
<li>异步线程执行超时，则调用AsyncListener的onTimeout(AsyncEvent event)方法；</li>
<li>异步执行完毕时，调用AsyncListener的onComplete(AsyncEvent event)方法；</li>
</ol>
<p>　　要注册一个AsyncListener，只需要将准备好的AsyncListener对象传递给AsyncContext对象的addListener()方法即可，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">AsyncContext ctx = req.startAsync(); </div><div class="line">ctx.addListener(new AsyncListener() &#123; </div><div class="line">    public void onComplete(AsyncEvent asyncEvent) throws IOException &#123; </div><div class="line">        // 做一些清理工作或者其他</div><div class="line">    &#125; </div><div class="line">    ... </div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h2 id="2、新增的注解支持"><a href="#2、新增的注解支持" class="headerlink" title="2、新增的注解支持"></a>2、新增的注解支持</h2><p>　　Servlet 3.0的部署描述文件web.xml的顶层标签<code>&lt;web-app&gt;</code>有一个metadata-complete属性，该属性指定当前的部署描述文件是否是完全的。如果设置为true，则容器在部署是将只依赖部署描述文件，忽略所有的注解（同时也会跳过web-fragment.xml的扫描，亦即禁用可插性支持，具体情况吼完关于可插性支持的讲解）；如果不配置该属性，或者将其设置为false，则表示启用注解支持（和可插性支持）。</p>
<h3 id="2-1、-WebServlet"><a href="#2-1、-WebServlet" class="headerlink" title="2.1、@WebServlet"></a>2.1、@WebServlet</h3><p>　　@WebServlet 用于将一个类声明为 Servlet，该注解将会在部署时被容器处理，容器将根据具体的属性配置将相应的类部署为 Servlet。该注解具有下表给出的一些常用属性（以下所有属性均为可选属性，但是 vlaue 或者 urlPatterns 通常是必需的，且二者不能共存，如果同时指定，通常是忽略 value 的取值）：<br>表1.@WebServlet主要属性列表<br>|属性名|类型|描述|<br>|——|—-|—-|<br>|name|String|指定Servletd name属性，等价于<code>&lt;serlvet-name&gt;</code>，如果没有显式指定，则该Servlet的取值即为类的全限定名|<br>|value|String[]|该属性等价于urlPatterns属性。两个属性不能同时相同|<br>|urlPatterns|String[]|指定一组Servlet的URL匹配模式。等价于<code>&lt;url-pattern&gt;</code>标签。|<br>|loadOnStartup|int|指定Servlet的加载顺序，等价于<code>&lt;load-on-start&gt;</code>标签|<br>|initParams|WebInitParam[]|指定一组Servlet初始化参数，等价于<code>&lt;init-param&gt;</code>标签|<br>|asyncSupported|boolean|声明Servlet是否支持异步操作模式，等价于&lt; async-supported|标签|<br>|description|String|该Servlet的描述信息，等价于<code>&lt;description&gt;</code>标签|<br>|displayName|String|该Servlet的显示名，通常配合工具使用，等价于<code>&lt;display-name&gt;</code>标签|</p>
<p>　　下面是一个简单的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">@WebServlet(urlPatterns = &#123;&quot;/simple&quot;&#125;, asyncSupported = true, </div><div class="line">loadOnStartup = -1, name = &quot;SimpleServlet&quot;, displayName = &quot;ss&quot;, </div><div class="line">initParams = &#123;@WebInitParam(name = &quot;username&quot;, value = &quot;tom&quot;)&#125; </div><div class="line">) </div><div class="line">public class SimpleServlet extends HttpServlet&#123; … &#125;</div></pre></td></tr></table></figure></p>
<p>　　如此配置之后，就可以不必在 web.xml 中配置相应的 <code>&lt;servlet&gt;</code>和 <code>&lt;servlet-mapping&gt;</code> 元素了，容器会在部署时根据指定的属性将该类发布为 Servlet。它的等价的 web.xml 配置形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;servlet&gt;</div><div class="line">    &lt;display-name&gt;ss&lt;/display-name&gt;</div><div class="line">    &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;servlet-class&gt;footmark.servlet.SimpleServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;load-on-startup&gt;-1&lt;/load-on-startup&gt;</div><div class="line">    &lt;async-supported&gt;true&lt;/async-supported&gt;</div><div class="line">    &lt;init-param&gt;</div><div class="line">        &lt;param-name&gt;username&lt;/param-name&gt;</div><div class="line">        &lt;param-value&gt;tom&lt;/param-value&gt;</div><div class="line">    &lt;/init-param&gt;</div><div class="line">&lt;/servlet&gt;</div><div class="line">&lt;servlet-mapping&gt;</div><div class="line">    &lt;servlet-name&gt;SimpleServlet&lt;/servlet-name&gt;</div><div class="line">    &lt;url-pattern&gt;/simple&lt;/url-pattern&gt;</div><div class="line">&lt;/servlet-mapping&gt;</div></pre></td></tr></table></figure></p>
<h3 id="2-2、-WebListener"><a href="#2-2、-WebListener" class="headerlink" title="2.2、@WebListener"></a>2.2、@WebListener</h3><p>　　该注解用于将类声明为监听器，被@WebListener标注的类必须实现以下至少一个接口：</p>
<ol>
<li>ServletContextListener；</li>
<li>ServletContextAttributeListener；</li>
<li>ServletRequestListener；</li>
<li>ServletRequestAttributeListener；</li>
<li>HttpSessionListener；</li>
<li>HttpSessionAttributeListener；</li>
</ol>
<p>　　该注解使用非常简单，其属性如下：<br>|属性名|类型|是否可选|描述|<br>|——|—-|——–|—-|<br>|value|String|是|该监听器的描述信息|</p>
<p>　　一个简单示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">@WebListener(&quot;This is only a demo listener&quot;)</div><div class="line">public class SimpleListener implements ServletContextListener &#123;...&#125;</div></pre></td></tr></table></figure></p>
<p>　　如此，则不需要在web.xml中配置<code>&lt;listener&gt;</code>标签了，它等价于web.xml中的配置形式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;listener&gt; </div><div class="line">    &lt;listener-class&gt;footmark.servlet.SimpleListener&lt;/listener-class&gt; </div><div class="line">&lt;/listener&gt;</div></pre></td></tr></table></figure></p>
<h3 id="2-3、-MultipartConfig"><a href="#2-3、-MultipartConfig" class="headerlink" title="2.3、@MultipartConfig"></a>2.3、@MultipartConfig</h3><p>　　该注解主要是为了辅助Servlet3.0中HttpServletRequest提供的对上传文件的支持。该注解标注在Servlet上面，以表示该Servlet希望处理的请求的MIME类型是multipart/form-data。另外，它还提供了若干属性用于简化对上传文件的处理，具体如下：<br>|属性名|类型|是否可选|描述|<br>|——|—-|——–|—-|<br>|fileSizeThreshold|int|是|当数据量大于该值时，内容将被写入文件。|<br>|location|String|是|存放生成文件地址|<br>|maxFileSize|long|是|允许上次文件最大值。默认值为-1，表示没有限制|<br>|maxRequestSize|long|是|针对该multipart/form-data 请求的最大数量，默认值为-1，表示没有限制|</p>
<h2 id="3、可插性支持"><a href="#3、可插性支持" class="headerlink" title="3、可插性支持"></a>3、可插性支持</h2><p>　　如果说3.0版本新增的注解支持是为了简化Servlet/过滤器/监听器的声明，从而是的web.xml变为可选配置，那么新增的可插性（pluggability）支持则将Servlet配置的灵活性提升到了新的高度。熟悉Struts2的开发这都知道，Struts2通过插件的形式提供了对包括Spring在内的各种开发框架的支持，开发者甚至可以自己为Struts2开发插件，而Servlet的可插性支持正是基于这样的理念而生产的。使用该特性，现在我们可以在不修改已有Web应用的前提下，只需要将按照一定格式打成的JAR包放到WEB-INF/lib目录下，即可实现新功能的扩展，不需要而外的配置。<br>　　Servlet 3.0引入了称之为“Web模块部署描述符骗的”的web-fragment.xml部署描述文件，该文件必须存放在JAR文件的META-INF目录下，该部署描述文件可以包含一切可以在web.xml中定义的内容。JAR包通常存放在WEB-INF/lib目录下，除此之外，所有该模块使用的资源，包括class文件、配置文件等，只需要能够被容器的类加载器链加载的路径上，比如classes目录等。<br>　　现在，为一个Web应用增加一个Servlet配置有如下三种（过滤器、监听器于Servlet三种的配置都是等价的，故在此以Servlet配置为例进行讲述，过滤器和监听器具有与之非常类似的特性）：</p>
<ol>
<li>编写一个类基础子HttpServlet，将该类放在classes目录下的对应包结构中，修改web.xml，在其中增加一个Servlet声明，这是最原始的方式；</li>
<li>编写一个类基础子HttpServlet，并且在该类上使用@WebServlet注解将该类声明为Servlet，将该类放在classes目录下的对应结构中，无需修改web.xml文件；</li>
<li>编写一个类继承自HttpServlet，将该类打包成JAR，并且在JAR包的META-INF目录下放一个web-fragment.xml文件，该文件中声明了响应的Servlet配置。web-fragment.xml文件示例如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class="line">&lt;web-fragment</div><div class="line">    xmlns=http://java.sun.com/xml/ns/javaee</div><div class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; version=&quot;3.0&quot;</div><div class="line">    xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee</div><div class="line">    http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd&quot;</div><div class="line">    metadata-complete=&quot;true&quot;&gt;</div><div class="line">    &lt;servlet&gt;</div><div class="line">        &lt;servlet-name&gt;fragment&lt;/servlet-name&gt;</div><div class="line">        &lt;servlet-class&gt;footmark.servlet.FragmentServlet&lt;/servlet-class&gt;</div><div class="line">    &lt;/servlet&gt;</div><div class="line">    &lt;servlet-mapping&gt;</div><div class="line">        &lt;servlet-name&gt;fragment&lt;/servlet-name&gt;</div><div class="line">        &lt;url-pattern&gt;/fragment&lt;/url-pattern&gt;</div><div class="line">    &lt;/servlet-mapping&gt;</div><div class="line">&lt;/web-fragment&gt;</div></pre></td></tr></table></figure>
</li>
</ol>
<p>　　从上面的示例可以看出，web-fragment.xml于web.xml除了在头部声明的XSD引用不同之外，其主体配置与web.xml完全一致的。<br>　　由于一个Web应用中可以互相多个web-fragment.xml声明文件，加上一个web.xml文件，加载顺序问题便成了不得不面对的问题。Servlet规范的专家组在设计的时候已经考虑到了这个我那天，并定义了加载顺序的规则。<br>　　web-fragment.xml包含了两个可选的顶层标签，<code>&lt;name&gt;</code>和<code>&lt;ordering&gt;</code>，如果希望为当前的文件指明的加载顺序，通常需要使用者两个标签<code>&lt;name&gt;</code>主要用于表示当前的文件，而<code>&lt;ordering&gt;</code>则用于指定先后顺序。一个简单的示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">&lt;web-fragment...&gt;</div><div class="line">    &lt;name&gt;FragmentA&lt;/name&gt;</div><div class="line">    &lt;ordering&gt;</div><div class="line">        &lt;after&gt;</div><div class="line">            &lt;name&gt;FragmentB&lt;/name&gt;</div><div class="line">            &lt;name&gt;FragmentC&lt;/name&gt;</div><div class="line">        &lt;/after&gt;</div><div class="line">    &lt;before&gt;</div><div class="line">        &lt;others/&gt;</div><div class="line">    &lt;/before&gt;</div><div class="line">    &lt;/ordering&gt;</div><div class="line">    ...</div><div class="line">&lt;/web-fragment&gt;</div></pre></td></tr></table></figure></p>
<p>　　如上所示，<code>&lt;name&gt;</code>标签的取值通常是被其他web-fragment.xml文件在定义先后顺序时引用的，在当前文件中一般用不着，它起着标识当前文件的作用。<br>　　在<code>&lt;ordering&gt;</code>标签内博，我们可以定义当前web-fragment.xml文件与其他文件的相对位置关系，着主要通过<code>&lt;ordering&gt;</code>的<code>&lt;after&gt;</code>和<code>&lt;before&gt;</code>子标签来实现的，在这两个字标签内部可以通过<code>&lt;name&gt;</code>标签来指定相对应的文件。比如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;after&gt; </div><div class="line">    &lt;name&gt;FragmentB&lt;/name&gt; </div><div class="line">    &lt;name&gt;FragmentC&lt;/name&gt; </div><div class="line">&lt;/after&gt;</div></pre></td></tr></table></figure></p>
<p>　　以上片段则表示当前文件必须在FragmentB和FragmentC之后解析。<code>&lt;before&gt;</code>的使用鱼此相同，它锁表示的是当前文件必须早于<code>&lt;before&gt;</code>标签里所列出的web-fragment.xml文件。<br>　　除了将所比较的文件通过<code>&lt;name&gt;</code>在<code>&lt;after&gt;</code>和<code>&lt;begin&gt;</code>中列出之外，Servlet还提供了一个简化标签<code>&lt;others&gt;</code>。它表示除了当前文件之外的其他所有的web-fragment.xml文件，该标签的优先级低于使用<code>&lt;name&gt;</code>并且制定的相对位置关系。</p>
<h2 id="4、ServletContext的性能增强"><a href="#4、ServletContext的性能增强" class="headerlink" title="4、ServletContext的性能增强"></a>4、ServletContext的性能增强</h2><p>　　除了以上的新特性之外，ServletContext对象的功能在新版本中也得到了增强。现在，该对象支持在运行时动态部署Servlet、过滤器、监听器，以及为Servlet和过滤器增强URL映射等。以Servlet为例，过滤器与监听器与之类似。ServletContext为动态配置Servlet增加如下方法：</p>
<ol>
<li>ServletRegistration.Dynamic addServlet(String servletName, Class&lt; ? extends Servlet&gt; ServletClass)；</li>
<li>ServletRegistration.Dynamic addServlet(String servletName, Servlet servlet)；</li>
<li>ServletRegistration.Dynamic addServlet(String servletName, String className)</li>
<li>&lt; T extends Servlet&gt; T createServlet(Class<t> clazz)；</t></li>
<li>ServletRegistration getServletRegistration(String servletName)</li>
<li>Map&lt; String, ? extends ServletRegistration&gt; getServletRegistartions()；</li>
</ol>
<p>　　其中前三个方法的租用是相同的，只是参数类型不同而已；通过createServlet()方法创建的Servlet，通常需要做一些自定义的配置，然后使用addServlet() 方法来将其动态注册为一个可以用于服务的Servlet。两个getServletRegistration() 方法主要用于动态为Servlet增加映射信息，这等价于在web.xml（抑或web-fragment.xml）中使用<code>&lt;servlet-mapping&gt;</code>标签为存在Servlet增加映射信息。<br>　　以上ServletContext新增的方法要么是在ServletContextListener的contextInitialized方法中调用，要么在ServletContainerInitializer的onStartup()方法中调用。<br>　　ServletContainerInitializer也是Servlet3.0新增的一个接口，容器在启动时使用JAR服务API(JAR Servlet API)来发现ServletContainerInitializer的实现类，并且容器将WEB-INF/lib目录下JAR包中的类都交给该类的onStartup()方法处理，我们通常需要在该实现类上使用@HandlesTypes注解来指定希望被处理的类，过滤掉不希望给onStartup()处理的类。
　　</p>
<h2 id="5、HttpServletRequest对文件上传的支持"><a href="#5、HttpServletRequest对文件上传的支持" class="headerlink" title="5、HttpServletRequest对文件上传的支持"></a>5、HttpServletRequest对文件上传的支持</h2><p>　　此前，对于处理上传文件的操作一直是让开发者头疼的问题，因为 Servlet 本身没有对此提供直接的支持，需要使用第三方框架来实现，而且使用起来也不够简单。如今这都成为了历史，Servlet 3.0 已经提供了这个功能，而且使用也非常简单。为此，HttpServletRequest 提供了两个方法用于从请求中解析出上传的文件：</p>
<ol>
<li>Part getPart(String name)；</li>
<li>Collection&lt; Part&gt; getParts()；</li>
</ol>
<p>　　前者用于获取请求中给定 name 的文件，后者用于获取所有的文件。每一个文件用一个 javax.servlet.http.Part 对象来表示。该接口提供了处理文件的简易方法，比如 write()、delete() 等。至此，结合 HttpServletRequest 和 Part 来保存上传的文件变得非常简单，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Part photo = request.getPart(&quot;photo&quot;); </div><div class="line">photo.write(&quot;/tmp/photo.jpg&quot;); </div><div class="line">// 可以将两行代码简化为 request.getPart(&quot;photo&quot;).write(&quot;/tmp/photo.jpg&quot;) 一行。</div></pre></td></tr></table></figure></p>
<p>　　另外，开发者可以配合前面提到的 @MultipartConfig 注解来对上传操作进行一些自定义的配置，比如限制上传文件的大小，以及保存文件的路径等。其用法非常简单，故不在此赘述了。<br>　　需要注意的是，如果请求的 MIME 类型不是 multipart/form-data，则不能使用上面的两个方法，否则将抛异常。
　　</p>
<h2 id="6、总结"><a href="#6、总结" class="headerlink" title="6、总结"></a>6、总结</h2><p>　　Servlet 3.0 的众多新特性使得 Servlet 开发变得更加简单，尤其是异步处理特性和可插性支持的出现，必将对现有的 MVC 框架产生深远影响。虽然我们通常不会自己去用 Servlet 编写控制层代码，但是也许在下一个版本的 Struts 中，您就能切实感受到这些新特性带来的实质性改变。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://moguichun.com/2017/07/02/Servlet3-0-新特性详解（转）/" data-id="cj4mcegtd00011sud59pj5bsl" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Java-Web/">Java Web</a></div><div class="post-nav"><a href="/2017/06/04/Java中枚举类型的简单使用/" class="next">Java中枚举类型的简单使用</a></div><div id="disqus_thread"><script>var disqus_shortname = 'moguichun';
var disqus_identifier = '2017/07/02/Servlet3-0-新特性详解（转）/';
var disqus_title = 'Servlet3.0 新特性详解（转）';
var disqus_url = 'http://moguichun.com/2017/07/02/Servlet3-0-新特性详解（转）/';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//moguichun.disqus.com/count.js" async></script></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://moguichun.com"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Java-Web/" style="font-size: 15px;">Java Web</a> <a href="/tags/问题解决/" style="font-size: 15px;">问题解决</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/07/02/Servlet3-0-新特性详解（转）/">Servlet3.0 新特性详解（转）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/06/04/Java中枚举类型的简单使用/">Java中枚举类型的简单使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/28/SpringMVC-Mybatis整合返回JSON数据出现的Could-not-write-content-No-serializer-found-for-class-错误解决办法/">SpringMVC + Mybatis整合返回JSON数据出现的Could not write content: No serializer found for class 错误解决办法</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/27/hello-world/">Hexo Usage</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-comment-o"> 最近评论</i></div><script type="text/javascript" src="//moguichun.disqus.com/recent_comments_widget.js?num_items=5&amp;hide_avatars=1&amp;avatar_size=32&amp;excerpt_length=20&amp;hide_mods=1"></script></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Quison's Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>